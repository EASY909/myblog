<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /**
         * ç®€å•å·¥åŽ‚æ¨¡å¼
         * **/
        function User(name, age, career, work) {
            this.name = name
            this.age = age
            this.career = career
            this.work = work
        }

        function Factory(name, age, career) {
            let work;
            switch (career) {
                case 'coder':
                    work = ['å†™ä»£ç ', 'å†™ç³»åˆ†', 'ä¿®Bug']
                    break;
                case 'product manager':
                    work = ['è®¢ä¼šè®®å®¤', 'å†™PRD', 'å‚¬æ›´']
                    break
                case 'boss':
                    work = ['å–èŒ¶', 'çœ‹æŠ¥', 'è§å®¢æˆ·']
                    break
                default:
                    work = ["å®¶é‡Œè¹²"]
                    break
            }
            return new User(name, age, career, work);
        }
        let f1 = new Factory("qc", 18, "coder");
        console.log(f1.work);


        /**
         * æŠ½è±¡å·¥åŽ‚æ¨¡å¼
         * **/
        class MobilePhoneFactory {
            // æä¾›æ“ä½œç³»ç»Ÿçš„æŽ¥å£
            createOS() {
                throw new Error("æŠ½è±¡å·¥åŽ‚æ–¹æ³•ä¸å…è®¸ç›´æŽ¥è°ƒç”¨ï¼Œä½ éœ€è¦å°†æˆ‘é‡å†™ï¼");
            }
            // æä¾›ç¡¬ä»¶çš„æŽ¥å£
            createHardWare() {
                throw new Error("æŠ½è±¡å·¥åŽ‚æ–¹æ³•ä¸å…è®¸ç›´æŽ¥è°ƒç”¨ï¼Œä½ éœ€è¦å°†æˆ‘é‡å†™ï¼");
            }
        }
        class FakeStarFactory extends MobilePhoneFactory {
            createOS() {
                // æä¾›å®‰å“ç³»ç»Ÿå®žä¾‹
                return new AndroidOS()
            }
            createHardWare() {
                // æä¾›é«˜é€šç¡¬ä»¶å®žä¾‹
                return new QualcommHardWare()
            }
        }
        // å®šä¹‰æ“ä½œç³»ç»Ÿè¿™ç±»äº§å“çš„æŠ½è±¡äº§å“ç±»
        class OS {
            controlHardWare() {
                throw new Error('æŠ½è±¡äº§å“æ–¹æ³•ä¸å…è®¸ç›´æŽ¥è°ƒç”¨ï¼Œä½ éœ€è¦å°†æˆ‘é‡å†™ï¼');
            }
        }

        // å®šä¹‰å…·ä½“æ“ä½œç³»ç»Ÿçš„å…·ä½“äº§å“ç±»
        class AndroidOS extends OS {
            controlHardWare() {
                console.log('æˆ‘ä¼šç”¨å®‰å“çš„æ–¹å¼åŽ»æ“ä½œç¡¬ä»¶')
            }
        }

        class AppleOS extends OS {
            controlHardWare() {
                console.log('æˆ‘ä¼šç”¨ðŸŽçš„æ–¹å¼åŽ»æ“ä½œç¡¬ä»¶')
            }
        }

        /**
         * å•ä¾‹æ¨¡å¼
         * **/
        const single = (function () {
            class Single {

            }

            let single;
            return {
                getSingle() {
                    if (!single) {
                        single = new Single();
                    }
                    return single;
                }
            }
        })();
        console.log(single.getSingle());

        /**
         * å‘å¸ƒè®¢é˜…
         * **/
        class EventEmitter {
            constructor() {
                this.handlers = {};
            }

            on(eventName, cb) {
                if (!this.handlers[eventName]) {
                    this.handlers[eventName] = [];
                }
                this.handlers[eventName].push(cb);
            }

            emit(eventName, ...args) {
                if (this.handlers[eventName]) {
                    this.handlers[eventName].forEach((cb) => {
                        cb(...args);
                    })
                }
            }

            off(eventName, cb) {
                const cbs = this.handlers[eventName];
                const index = cbs.indexOf(cb);
                if (index !== -1) cbs.splice(index, 1);
            }

            once(eventName, cb) {
                const wrapper = (...args) => {
                    cb.apply(...args);
                    this.off(eventName, wrapper);
                }
                this.on(eventName, wrapper);
            }
        }

        /**
        è§‚å¯Ÿè€…æ¨¡å¼
        **/
        class Subscribe {
            constructor() {
                this.pond = [];
            }

            add(fn) {
                let pond = this.pond,
                    isExist = false;
                pond.forEach(item => {
                        item === fn ? isExist = true : null;
                    })

                    !isExist ? pond.push(fn) : null;
            }

            remove(fn) {
                let pond = this.pond;
                pond.forEach((item, index) => {
                    if (item === fn) {
                        pond[index] = null;
                        //  pond.splice(index,1) 
                    }
                })
            }
            fire(...arg) {
                let pond = this.pond;

                for (let i = 0; i < pond.length; i++) {
                    let item = pond[i];
                    if (item === null) {
                        pond.splice(i, 1);
                        i--;
                        continue;
                    }
                    item(...arg)
                }
            }
        }
    </script>
</head>

<body>

</body>

</html>